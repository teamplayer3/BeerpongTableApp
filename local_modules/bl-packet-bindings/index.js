const U8_BYTES = 1, U16_BYTES = 2, U32_BYTES = 4, U64_BYTES = 8, U128_BYTES = 16;
const de_zig_zag_signed = t => void 0 === t ? void 0 : t >> 1 ^ -(1 & t), zig_zag = (t, e) => e << 1 ^ e >> 8 * t, varint_max = t => Math.floor((8 * t + 7) / 7), max_val = t => Math.pow(2, 8 * t) - 1;
class Deserializer{bytes;constructor(t){this.bytes=Array.from(t)}pop_next=()=>{let t=this.bytes.shift();if(void 0===t)throw "input buffer too small";return t};pop_n=t=>{let e=[];for(let i=0;i<t;i++)e.push(this.bytes.shift());return e};get_uint8=()=>this.pop_next();try_take=t=>{let e=0,i=max_val(t);for(let s=0;s<varint_max(t);s++){let r=this.pop_next(),h=127&r;if(e|=h<<7*s,(128&r)==0){if(!(h>i))return e;throw "Bad Variant"}}};deserialize_bool=()=>{let t=this.pop_next();return void 0===t?void 0:t>0};deserialize_number=(t,e)=>{if(t===U8_BYTES)return this.get_uint8();if(t===U16_BYTES||t===U32_BYTES||t===U64_BYTES||t===U128_BYTES)return e?de_zig_zag_signed(this.try_take(U16_BYTES)):this.try_take(U16_BYTES);throw "byte count not supported"};deserialize_string=()=>{let t=this.pop_n(this.try_take(U32_BYTES));return String.fromCharCode(...t)};deserialize_array=t=>[...Array(this.try_take(U32_BYTES))].map(()=>t(this))}
class Serializer{bytes=[];finish=()=>this.bytes;serialize_bool=t=>this.serialize_number(U8_BYTES,!1,t?1:0);serialize_number=(t,e,i)=>{if(t===U8_BYTES)this.bytes.push(i);else if(t===U16_BYTES||t===U32_BYTES||t===U64_BYTES||t===U128_BYTES){let s=e?this.varint(t,zig_zag(t,i)):this.varint(t,i);this.push_n(s)}else throw "byte count not supported"};serialize_string=t=>{this.push_n(this.varint(U32_BYTES,t.length));let e=[];for(let i of t)e.push(i.charCodeAt(0));this.push_n(e)};serialize_array=(t,e)=>{this.push_n(this.varint(U32_BYTES,e.length)),e.forEach(e=>t(this,e))};push_n=t=>{t.forEach(t=>this.bytes.push(t))};varint=(t,e)=>{let i=e,s=[];for(let r=0;r<varint_max(t);r++){if(s.push(255&i),i<128)return s;s[r]|=128,i>>=7}}}
const serialize_COLOR = (s, v) => { s.serialize_number(U8_BYTES, false, v.r); s.serialize_number(U8_BYTES, false, v.g); s.serialize_number(U8_BYTES, false, v.b) }
const deserialize_COLOR = (d) => ({ r: d.deserialize_number(U8_BYTES, false), g: d.deserialize_number(U8_BYTES, false), b: d.deserialize_number(U8_BYTES, false) })
const serialize_COLOR_VARIANT = (s, v) => { switch (v.tag) { case "Color": s.serialize_number(U32_BYTES, false, 0); serialize_COLOR(s, v.value); break; case "Gradient": s.serialize_number(U32_BYTES, false, 1); serialize_GRADIENT(s, v.value); break } }
const deserialize_COLOR_VARIANT = (d) => { switch (d.deserialize_number(U32_BYTES, false)) { case 0: return { tag: "Color" , value: deserialize_COLOR(d) }; case 1: return { tag: "Gradient" , value: deserialize_GRADIENT(d) }; default: throw "variant not implemented" } }
const serialize_GRADIENT = (s, v) => { serialize_COLOR(s, v.from); serialize_COLOR(s, v.to) }
const deserialize_GRADIENT = (d) => ({ from: deserialize_COLOR(d), to: deserialize_COLOR(d) })
const serialize_INDEX_VARIANT = (s, v) => { switch (v.tag) { case "Index": s.serialize_number(U32_BYTES, false, 0); s.serialize_number(U16_BYTES, false, v.value); break; case "Range": s.serialize_number(U32_BYTES, false, 1); s.serialize_number(U16_BYTES, false, v.value.start); s.serialize_number(U16_BYTES, false, v.value.end); break; case "List": s.serialize_number(U32_BYTES, false, 2); s.serialize_array((s, v) => s.serialize_number(U16_BYTES, false, v), v.value); break; case "EveryN": s.serialize_number(U32_BYTES, false, 3); s.serialize_number(U16_BYTES, false, v.value.range.start); s.serialize_number(U16_BYTES, false, v.value.range.end); s.serialize_number(U16_BYTES, false, v.value.n); break; case "EveryOdd": s.serialize_number(U32_BYTES, false, 4); s.serialize_number(U16_BYTES, false, v.value.range.start); s.serialize_number(U16_BYTES, false, v.value.range.end); s.serialize_number(U16_BYTES, false, v.value.n); break; case "EveryEven": s.serialize_number(U32_BYTES, false, 5); s.serialize_number(U16_BYTES, false, v.value.range.start); s.serialize_number(U16_BYTES, false, v.value.range.end); s.serialize_number(U16_BYTES, false, v.value.n); break } }
const deserialize_INDEX_VARIANT = (d) => { switch (d.deserialize_number(U32_BYTES, false)) { case 0: return { tag: "Index" , value: d.deserialize_number(U16_BYTES, false) }; case 1: return { tag: "Range" , value: { start: d.deserialize_number(U16_BYTES, false), end: d.deserialize_number(U16_BYTES, false) } }; case 2: return { tag: "List" , value: d.deserialize_array(() => d.deserialize_number(U16_BYTES, false)) }; case 3: return { tag: "EveryN" , value: { range: { start: d.deserialize_number(U16_BYTES, false), end: d.deserialize_number(U16_BYTES, false) }, n: d.deserialize_number(U16_BYTES, false) } }; case 4: return { tag: "EveryOdd" , value: { range: { start: d.deserialize_number(U16_BYTES, false), end: d.deserialize_number(U16_BYTES, false) }, n: d.deserialize_number(U16_BYTES, false) } }; case 5: return { tag: "EveryEven" , value: { range: { start: d.deserialize_number(U16_BYTES, false), end: d.deserialize_number(U16_BYTES, false) }, n: d.deserialize_number(U16_BYTES, false) } }; default: throw "variant not implemented" } }
const serialize_MODULE_SIDE = (s, v) => { switch (v.tag) { case "Both": s.serialize_number(U32_BYTES, false, 0); break; case "Main": s.serialize_number(U32_BYTES, false, 1); break; case "Secondary": s.serialize_number(U32_BYTES, false, 2); break } }
const deserialize_MODULE_SIDE = (d) => { switch (d.deserialize_number(U32_BYTES, false)) { case 0: return { tag: "Both" }; case 1: return { tag: "Main" }; case 2: return { tag: "Secondary" }; default: throw "variant not implemented" } }
const serialize_MULTI_PART = (s, v) => { serialize_MODULE_SIDE(s, v.module); serialize_INDEX_VARIANT(s, v.index); serialize_COLOR_VARIANT(s, v.color) }
const deserialize_MULTI_PART = (d) => ({ module: deserialize_MODULE_SIDE(d), index: deserialize_INDEX_VARIANT(d), color: deserialize_COLOR_VARIANT(d) })
const serialize_OPERATION = (s, v) => { switch (v.tag) { case "set_part_color": s.serialize_number(U32_BYTES, false, 0); serialize_SET_PART_COLOR(s, v.value); break; case "animate_part": s.serialize_number(U32_BYTES, false, 1); break } }
const deserialize_OPERATION = (d) => { switch (d.deserialize_number(U32_BYTES, false)) { case 0: return { tag: "set_part_color" , value: deserialize_SET_PART_COLOR(d) }; case 1: return { tag: "animate_part" }; default: throw "variant not implemented" } }
const serialize_PACKET = (s, v) => { serialize_OPERATION(s, v.operation) }
const deserialize_PACKET = (d) => ({ operation: deserialize_OPERATION(d) })
const serialize_PART = (s, v) => { switch (v.tag) { case "Led": s.serialize_number(U32_BYTES, false, 0); serialize_MODULE_SIDE(s, v.value.module); s.serialize_number(U16_BYTES, false, v.value.index); serialize_COLOR(s, v.value.color); break; case "Pot": s.serialize_number(U32_BYTES, false, 1); serialize_MULTI_PART(s, v.value); break; case "Module": s.serialize_number(U32_BYTES, false, 2); serialize_MODULE_SIDE(s, v.value.module); serialize_COLOR(s, v.value.color); break; case "SideBack": s.serialize_number(U32_BYTES, false, 3); serialize_MULTI_PART(s, v.value); break; case "SideFront": s.serialize_number(U32_BYTES, false, 4); serialize_MULTI_PART(s, v.value); break } }
const deserialize_PART = (d) => { switch (d.deserialize_number(U32_BYTES, false)) { case 0: return { tag: "Led" , value: { module: deserialize_MODULE_SIDE(d), index: d.deserialize_number(U16_BYTES, false), color: deserialize_COLOR(d) } }; case 1: return { tag: "Pot" , value: deserialize_MULTI_PART(d) }; case 2: return { tag: "Module" , value: { module: deserialize_MODULE_SIDE(d), color: deserialize_COLOR(d) } }; case 3: return { tag: "SideBack" , value: deserialize_MULTI_PART(d) }; case 4: return { tag: "SideFront" , value: deserialize_MULTI_PART(d) }; default: throw "variant not implemented" } }
const serialize_SET_PART_COLOR = (s, v) => { serialize_PART(s, v.part) }
const deserialize_SET_PART_COLOR = (d) => ({ part: deserialize_PART(d) })
const is_COLOR = (v) => (typeof v === "object" && typeof v.r === "number" && typeof v.g === "number" && typeof v.b === "number")
const is_COLOR_VARIANT = (v) => ((typeof v === "object" && "tag" in v && "value" in v && (v.tag === "Color" && is_COLOR(v.value)) || (v.tag === "Gradient" && is_GRADIENT(v.value))))
const is_GRADIENT = (v) => (typeof v === "object" && is_COLOR(v.from) && is_COLOR(v.to))
const is_INDEX_VARIANT = (v) => ((typeof v === "object" && "tag" in v && "value" in v && (v.tag === "Index" && typeof v.value === "number") || (v.tag === "Range" && typeof v.value === "object" && "start" in v.value && "end" in v.value) || (v.tag === "List" && Array.isArray(v.value)) || (v.tag === "EveryN" && typeof v.value === "object" && typeof v.value.range === "object" && "start" in v.value.range && "end" in v.value.range && typeof v.value.n === "number") || (v.tag === "EveryOdd" && typeof v.value === "object" && typeof v.value.range === "object" && "start" in v.value.range && "end" in v.value.range && typeof v.value.n === "number") || (v.tag === "EveryEven" && typeof v.value === "object" && typeof v.value.range === "object" && "start" in v.value.range && "end" in v.value.range && typeof v.value.n === "number")))
const is_MODULE_SIDE = (v) => ((typeof v === "object" && "tag" && v.tag === "Both" && v.tag === "Main" && v.tag === "Secondary"))
const is_MULTI_PART = (v) => (typeof v === "object" && is_MODULE_SIDE(v.module) && is_INDEX_VARIANT(v.index) && is_COLOR_VARIANT(v.color))
const is_OPERATION = (v) => ((typeof v === "object" && "tag" && v.tag === "animate_part") || (typeof v === "object" && "tag" in v && "value" in v && (v.tag === "set_part_color" && is_SET_PART_COLOR(v.value))))
const is_PACKET = (v) => (typeof v === "object" && is_OPERATION(v.operation))
const is_PART = (v) => ((typeof v === "object" && "tag" in v && "value" in v && (v.tag === "Led" && typeof v.value === "object" && is_MODULE_SIDE(v.value.module) && typeof v.value.index === "number" && is_COLOR(v.value.color)) || (v.tag === "Pot" && is_MULTI_PART(v.value)) || (v.tag === "Module" && typeof v.value === "object" && is_MODULE_SIDE(v.value.module) && is_COLOR(v.value.color)) || (v.tag === "SideBack" && is_MULTI_PART(v.value)) || (v.tag === "SideFront" && is_MULTI_PART(v.value))))
const is_SET_PART_COLOR = (v) => (typeof v === "object" && is_PART(v.part))
module.exports.serialize = (type, value) => {
    if (!(typeof type === "string")) {
        throw "type must be a string"
    }
    const s = new Serializer()
    switch (type) { case "Color": if (is_COLOR(value)) { serialize_COLOR(s, value) } else throw "value has wrong format"; break; case "ColorVariant": if (is_COLOR_VARIANT(value)) { serialize_COLOR_VARIANT(s, value) } else throw "value has wrong format"; break; case "Gradient": if (is_GRADIENT(value)) { serialize_GRADIENT(s, value) } else throw "value has wrong format"; break; case "IndexVariant": if (is_INDEX_VARIANT(value)) { serialize_INDEX_VARIANT(s, value) } else throw "value has wrong format"; break; case "ModuleSide": if (is_MODULE_SIDE(value)) { serialize_MODULE_SIDE(s, value) } else throw "value has wrong format"; break; case "MultiPart": if (is_MULTI_PART(value)) { serialize_MULTI_PART(s, value) } else throw "value has wrong format"; break; case "Operation": if (is_OPERATION(value)) { serialize_OPERATION(s, value) } else throw "value has wrong format"; break; case "Packet": if (is_PACKET(value)) { serialize_PACKET(s, value) } else throw "value has wrong format"; break; case "Part": if (is_PART(value)) { serialize_PART(s, value) } else throw "value has wrong format"; break; case "SetPartColor": if (is_SET_PART_COLOR(value)) { serialize_SET_PART_COLOR(s, value) } else throw "value has wrong format"; break }
    return s.finish()
}
module.exports.deserialize = (type, bytes) => {
    if (!(typeof type === "string")) {
        throw "type must be a string"
    }
    const d = new Deserializer(bytes)
    switch (type) { case "Color": return deserialize_COLOR(d); case "ColorVariant": return deserialize_COLOR_VARIANT(d); case "Gradient": return deserialize_GRADIENT(d); case "IndexVariant": return deserialize_INDEX_VARIANT(d); case "ModuleSide": return deserialize_MODULE_SIDE(d); case "MultiPart": return deserialize_MULTI_PART(d); case "Operation": return deserialize_OPERATION(d); case "Packet": return deserialize_PACKET(d); case "Part": return deserialize_PART(d); case "SetPartColor": return deserialize_SET_PART_COLOR(d) }
}
